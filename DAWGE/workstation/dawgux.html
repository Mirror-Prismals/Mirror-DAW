<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Oxblood DAW + Transport + Right-Click Menu + Add Node Window (Ruby Tabs)</title>
  <style>
    :root {
      /* Oxblood background */
      --bg-center: #400000;
      --bg-edge: #100000;

      /* Panel colors */
      --sample-color: #803030;   /* sample manager */
      --timeline-color: #602020; /* timeline */
      --fxchain-color: #701010;  /* fx chain */

      /* For the timeline's bevel animation */
      --bevel-dark-rgb: 0, 0, 0;
      --bevel-light-rgb: 255, 255, 255;
      
      /* Darker version of timeline color for the outer grid lines */
      --timeline-dark: 67, 22, 22;
      
      /* Inner grid color: a shade between timeline-dark and the timeline base.
         (Outer grid lines use opacity 0.7; here we use 0.5 so the inner lines are lighter.) */
      --inner-grid-opacity: 0.5;

      /* Ruby-ish reds for the transport, menus, popups, and now the tabs */
      --ruby-bg: #701010;
      --ruby-border: #500000;
      --ruby-hover: #803030;
      --ruby-text:  #f0f0f0;
      --ruby-muted: #c0c0c0;
      --ruby-disabled: #999;
    }

    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    /* Main layout controlled dynamically by JS */
    body {
      background: radial-gradient(circle at center, var(--bg-center), var(--bg-edge));
      display: grid;
      width: 100vw; 
      height: 100vh;
      grid-template-columns: 20% 80%;
      grid-template-rows: 70% 30%;
      grid-template-areas:
        "sample timeline"
        "sample fxchain";
      overflow: hidden;
      font-family: sans-serif;
      user-select: none; /* prevents accidental text selection during dragging */
      color: var(--ruby-text);
    }

    /* Sample Manager (left column) */
    .sample-container {
      grid-area: sample;
      position: relative;
      overflow: visible;
      background: #222;
    }
    .sample-manager {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: var(--sample-color);
      border-radius: 8px;
      box-shadow: 0 0 8px rgba(0,0,0,0.8) inset;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 1.2rem;
      color: white;
      transition: transform 0.5s ease, opacity 0.5s ease;
    }
    .sample-manager::before {
      content: "SAMPLE MANAGER";
    }
    .sample-manager.hidden {
      transform: translateX(calc(-100% + 20px));
      opacity: 0.4;
    }
    .sample-manager.hidden::before {
      position: absolute;
      left: 0;
      top: 50%;
      transform: translate(calc(-100% + 180px), -50%) rotate(90deg);
      transform-origin: left center;
      white-space: nowrap;
    }

    /* Sample tab – now using Ruby colors */
    .sample-tab {
      position: absolute;
      top: 0;
      left: 0;
      width: 20px;
      height: 40px;
      background: var(--ruby-bg);
      border: 1px solid var(--ruby-border);
      border-radius: 0 0 8px 0;
      box-shadow: 0 2px 4px rgba(0,0,0,0.7);
      cursor: pointer;
      color: var(--ruby-text);
      font-size: 0.8rem;
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 10;
    }
    .sample-tab:hover {
      background: var(--ruby-hover);
    }
    .sample-tab::before {
      content: "←";
    }
    .sample-manager.hidden + .sample-tab::before {
      content: "→";
    }

    /* Timeline (top-right) */
    .timeline {
      grid-area: timeline;
      position: relative; /* For absolute positioning of child elements */
      background: var(--timeline-color);
      border-radius: 8px;
      margin-left: 10px;
      margin-bottom: 10px;
      box-shadow:
        inset 4px 4px 8px rgba(var(--bevel-dark-rgb),1),
        inset -4px -4px 8px rgba(var(--bevel-light-rgb),0.5),
        0 4px 6px rgba(0,0,0,0.7);
      transition: margin 0.5s ease, box-shadow 0.5s ease;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 1.2rem;
      cursor: grab;
      color: white;
      /* Grid lines for timeline */
      background-image: 
        linear-gradient(90deg, rgba(var(--timeline-dark), 0.7) 1px, transparent 1px),
        linear-gradient(0deg, rgba(var(--timeline-dark), 0.7) 1px, transparent 1px),
        linear-gradient(90deg, rgba(var(--timeline-dark), var(--inner-grid-opacity)) 0.5px, transparent 0.5px),
        linear-gradient(0deg, rgba(var(--timeline-dark), var(--inner-grid-opacity)) 0.5px, transparent 0.5px);
      background-position: 0 0;
      /* background-size controlled via JS (zoom) */
    }
    .timeline::before {
      content: "TIMELINE";
    }

    /* FX Chain (bottom-right) */
    .fxchain-container {
      grid-area: fxchain;
      position: relative;
      overflow: visible;
      background: #222;
    }
    .fx-chain {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: var(--fxchain-color);
      border-radius: 8px;
      box-shadow: 0 0 8px rgba(0,0,0,0.8) inset;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 1.2rem;
      color: white;
      transition: transform 0.5s ease, opacity 0.5s ease;
    }
    .fx-chain::before {
      content: "FX CHAIN";
    }
    .fx-chain.hidden {
      transform: translateY(100%);
      opacity: 0.4;
    }

    /* FX tab – now using Ruby colors */
    .fx-tab {
      position: absolute;
      top: 0;
      left: 50%;
      transform: translate(-50%, -40px);
      width: 80px;
      height: 20px;
      background: var(--ruby-bg);
      border: 1px solid var(--ruby-border);
      border-radius: 8px 8px 0 0;
      box-shadow: 0 2px 4px rgba(0,0,0,0.7);
      cursor: pointer;
      color: var(--ruby-text);
      font-size: 0.8rem;
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 10;
    }
    .fx-tab:hover {
      background: var(--ruby-hover);
    }
    .fx-tab::before {
      content: "↓";
    }
    .fx-chain.hidden + .fx-tab::before {
      content: "↑";
    }

    /* =============== Transport Node (Ruby Style) =============== */
    .transport-node {
      position: absolute;
      /* Left-align inside timeline */
      top: 40px;
      left: 10px;
      display: flex;
      align-items: center;
      background: var(--ruby-bg);
      border: 1px solid var(--ruby-border);
      border-radius: 6px;
      padding: 4px 6px;
      color: var(--ruby-text);
      font-size: 0.9rem;
      min-height: 30px;
      box-shadow: 0 2px 4px rgba(0,0,0,0.5);
      z-index: 999;
    }
    .transport-handle {
      cursor: grab;
      margin-right: 8px;
      color: var(--ruby-muted);
      display: flex;
      align-items: center;
      padding: 0 4px;
    }
    .transport-handle:hover {
      color: #fff;
    }

    /* Queue button (icon, label, caret) */
    .queue-button {
      position: relative;
      display: flex;
      align-items: center;
      background: var(--ruby-bg);
      border: 1px solid var(--ruby-border);
      border-radius: 4px;
      padding: 0 8px;
      margin-right: 8px;
      cursor: pointer;
    }
    .queue-button:hover {
      background: var(--ruby-hover);
    }
    .queue-icon {
      margin-right: 4px;
      color: #fff;
      font-weight: bold;
    }
    .queue-label {
      color: var(--ruby-text);
      margin-right: 4px;
    }
    .caret {
      color: var(--ruby-muted);
      font-size: 0.7rem;
    }
    .queue-dropdown {
      position: absolute;
      top: 100%;
      left: 0;
      background: var(--ruby-bg);
      border: 1px solid var(--ruby-border);
      border-radius: 4px;
      list-style: none;
      padding: 4px 0;
      margin: 4px 0 0 0;
      min-width: 120px;
      display: none;
      z-index: 999;
      box-shadow: 0 2px 4px rgba(0,0,0,0.7);
    }
    .queue-dropdown li {
      padding: 4px 8px;
      cursor: pointer;
      color: var(--ruby-text);
    }
    .queue-dropdown li:hover {
      background: var(--ruby-hover);
    }

    /* Batch size spinner */
    .batch-size {
      display: flex;
      align-items: center;
      margin-right: 8px;
    }
    .batch-size input[type="number"] {
      width: 50px;
      background: var(--ruby-bg);
      border: 1px solid var(--ruby-border);
      border-radius: 4px;
      color: var(--ruby-text);
      text-align: center;
      outline: none;
      -moz-appearance: textfield;
    }
    .batch-size input[type="number"]::-webkit-inner-spin-button,
    .batch-size input[type="number"]::-webkit-outer-spin-button {
      margin: 0;
      -webkit-appearance: none;
    }

    /* Stop and Stop All buttons */
    .stop-btn,
    .stop-all-btn {
      background: var(--ruby-bg);
      border: 1px solid var(--ruby-border);
      border-radius: 4px;
      color: var(--ruby-text);
      width: 28px;
      height: 28px;
      display: flex;
      align-items: center;
      justify-content: center;
      margin-right: 4px;
      cursor: pointer;
      font-weight: bold;
    }
    .stop-all-btn {
      margin-right: 0;
    }
    .stop-btn:hover,
    .stop-all-btn:hover {
      background: var(--ruby-hover);
    }

    /* ===================== TIMELINE CONTEXT MENU (Ruby Style) ===================== */
    .timeline-menu {
      position: absolute;
      display: none;
      background: var(--ruby-bg);
      border: 1px solid var(--ruby-border);
      border-radius: 4px;
      list-style: none;
      padding: 4px 0;
      margin: 0;
      font-size: 0.9rem;
      color: var(--ruby-text);
      z-index: 9999; /* above everything else */
      box-shadow: 0 2px 8px rgba(0,0,0,0.7);
      min-width: 180px;
    }
    .timeline-menu li {
      padding: 6px 12px;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: space-between; /* to position sub-menu arrow on right */
    }
    .timeline-menu li:hover {
      background: var(--ruby-hover);
    }
    .timeline-menu hr {
      border: none;
      border-top: 1px solid var(--ruby-border);
      margin: 4px 0;
    }
    .timeline-menu li.disabled {
      color: var(--ruby-disabled);
      cursor: default;
    }
    .timeline-menu li.disabled:hover {
      background: none; /* no highlight */
    }
    .timeline-menu .submenu-arrow {
      margin-left: 8px;
      color: var(--ruby-muted);
    }
    /* Submenu placeholder styling */
    .submenu-list {
      position: absolute;
      top: 0;
      left: 100%;
      margin-left: -1px;
      padding-left: 0;
      display: none;
      background: var(--ruby-bg);
      border: 1px solid var(--ruby-border);
      border-radius: 4px;
      box-shadow: 0 2px 8px rgba(0,0,0,0.7);
      list-style: none;
      min-width: 150px;
    }
    .submenu-list li {
      padding: 6px 12px;
      cursor: pointer;
      color: var(--ruby-text);
    }
    .submenu-list li:hover {
      background: var(--ruby-hover);
    }
    .timeline-menu li.submenu:hover .submenu-list {
      display: block;
    }

    /* ========== Add Node Window (Ruby style) ========== */
    .add-node-panel {
      position: absolute;
      display: none; /* hidden by default */
      top: 0; left: 0;
      width: 240px;
      background: var(--ruby-bg);
      border: 1px solid var(--ruby-border);
      border-radius: 6px;
      box-shadow: 0 2px 6px rgba(0,0,0,0.7);
      z-index: 10000; /* on top of everything else */
      font-size: 0.9rem;
      color: var(--ruby-text);
    }
    .add-node-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      background: var(--ruby-hover);
      padding: 6px 8px;
      border-radius: 6px 6px 0 0;
      cursor: grab; /* can drag the window by the header */
    }
    .add-node-title {
      font-weight: bold;
    }
    .add-node-buttons {
      display: flex;
      gap: 8px;
    }
    .add-node-btn {
      background: transparent;
      border: none;
      color: var(--ruby-text);
      cursor: pointer;
      font-size: 1rem;
      padding: 0;
    }
    .add-node-btn:hover {
      color: #fff;
    }
    .add-node-content {
      padding: 8px;
      display: block; /* toggled by expand/collapse */
    }
    .node-type-item {
      padding: 4px 0;
      cursor: pointer;
    }
    .node-type-item:hover {
      background: var(--ruby-hover);
    }
  </style>
</head>
<body>
  <!-- Sample Manager (left 20%) -->
  <div class="sample-container">
    <div class="sample-manager" id="sampleManager"></div>
    <div class="sample-tab" id="sampleTab"></div>
  </div>

  <!-- Timeline (top-right) -->
  <div class="timeline" id="timeline">
    <!-- Transport Node (ruby style) -->
    <div class="transport-node" id="transportNode">
      <!-- Drag handle -->
      <div class="transport-handle" id="transportHandle">&#8942;</div>
      <!-- Queue button -->
      <div class="queue-button" id="queueButton">
        <span class="queue-icon" id="queueIcon">></span>
        <span class="queue-label" id="queueLabel">Queue</span>
        <span class="caret" id="queueCaret">▾</span>
        <ul class="queue-dropdown" id="queueDropdown">
          <li data-icon=">" data-label="Queue">Queue</li>
          <li data-icon=">>" data-label="Queue (Instant)">Queue (Instant)</li>
          <li data-icon="|>" data-label="Queue (On Change)">Queue (On Change)</li>
        </ul>
      </div>
      <!-- Batch size spinner -->
      <div class="batch-size">
        <input type="number" value="1" min="1" id="batchInput" />
      </div>
      <!-- Stop (X) and Stop All (square) -->
      <button class="stop-btn" id="stopBtn">X</button>
      <button class="stop-all-btn" id="stopAllBtn">■</button>
    </div>
  </div>

  <!-- FX Chain (bottom-right) -->
  <div class="fxchain-container">
    <div class="fx-chain" id="fxChain"></div>
    <div class="fx-tab" id="fxTab"></div>
  </div>

  <!-- Timeline context menu -->
  <ul class="timeline-menu" id="timelineMenu">
    <li id="menuAddNode">Add Node</li>
    <li id="menuAddGroup">Add Group</li>
    <hr />
    <li class="disabled" id="menuConvertGroup">Convert to Group Node</li>
    <li class="disabled" id="menuManageGroups">Manage Group Nodes</li>
    <li class="disabled" id="menuAddGroupSelected">Add Group For Selected Nodes</li>
    <hr />
    <li id="menuSaveTemplate">Save Selected as Template</li>
    <li class="submenu" id="menuNodeTemplates">
      Node Templates
      <span class="submenu-arrow">></span>
      <!-- Submenu placeholder -->
      <ul class="submenu-list">
        <li>Template 1</li>
        <li>Template 2</li>
      </ul>
    </li>
  </ul>

  <!-- "Add Node" Expandable Window -->
  <div class="add-node-panel" id="addNodePanel">
    <div class="add-node-header" id="addNodeHeader">
      <span class="add-node-title">Add Node</span>
      <div class="add-node-buttons">
        <!-- Expand/collapse arrow -->
        <button class="add-node-btn" id="addNodeToggle">▼</button>
        <!-- Close button -->
        <button class="add-node-btn" id="addNodeClose">✕</button>
      </div>
    </div>
    <div class="add-node-content" id="addNodeContent">
      <div class="node-type-item">Node Type A</div>
      <div class="node-type-item">Node Type B</div>
      <div class="node-type-item">Node Type C</div>
    </div>
  </div>

  <script>
    /* 
      1) Toggling sample manager & FX chain
      2) Updating body grid dimensions
      3) Animating timeline bevel
      4) Infinite grid dragging on timeline
      5) Zoom in/out for the grid
      6) Transport node (drag handle, queue dropdown, etc.)
      7) Right-click context menu on timeline
      8) "Add Node" window
    */
    const sampleManager = document.getElementById('sampleManager');
    const sampleTab = document.getElementById('sampleTab');
    const fxChain = document.getElementById('fxChain');
    const fxTab = document.getElementById('fxTab');
    const timeline = document.getElementById('timeline');
    const bodyGrid = document.body.style;

    // Animate timeline bevel
    let timelineBevelProgress = 0;
    let timelineTargetProgress = 0;
    let bevelStartTime = null;
    const bevelDuration = 500;
    function lerp(a, b, t) {
      return a + (b - a) * t;
    }
    function updateTimelineBevel(progress) {
      const inset = lerp(4, 8, progress);
      const blur = lerp(8, 16, progress);
      const outerY = lerp(4, 6, progress);
      const outerBlur = lerp(6, 10, progress);
      const outerAlpha = lerp(0.7, 0.9, progress);
      const boxShadow = `inset ${inset}px ${inset}px ${blur}px rgba(0,0,0,1),
                         inset -${inset}px -${inset}px ${blur}px rgba(255,255,255,0.5),
                         0 ${outerY}px ${outerBlur}px rgba(0,0,0,${outerAlpha})`;
      timeline.style.boxShadow = boxShadow;
    }
    function animateBevel(ts) {
      if (!bevelStartTime) bevelStartTime = ts;
      const elapsed = ts - bevelStartTime;
      const t = Math.min(elapsed / bevelDuration, 1);
      timelineBevelProgress = timelineBevelProgress + (timelineTargetProgress - timelineBevelProgress) * t;
      updateTimelineBevel(timelineBevelProgress);
      if (t < 1) {
        requestAnimationFrame(animateBevel);
      } else {
        timelineBevelProgress = timelineTargetProgress;
        bevelStartTime = null;
      }
    }
    function setTimelineBevel(target) {
      timelineTargetProgress = target;
      bevelStartTime = null;
      requestAnimationFrame(animateBevel);
    }
    function updateBodyGrid() {
      const sampleHidden = sampleManager.classList.contains('hidden');
      const fxHidden = fxChain.classList.contains('hidden');
      const newCols = sampleHidden ? '0% 100%' : '20% 80%';
      const newRows = fxHidden ? '100% 0%' : '70% 30%';
      bodyGrid.gridTemplateColumns = newCols;
      bodyGrid.gridTemplateRows = newRows;
    }
    function toggleSample() {
      sampleManager.classList.toggle('hidden');
      updateBodyGrid();
      if (sampleManager.classList.contains('hidden') || fxChain.classList.contains('hidden')) {
        setTimelineBevel(1);
      } else {
        setTimelineBevel(0);
      }
    }
    function toggleFX() {
      fxChain.classList.toggle('hidden');
      updateBodyGrid();
      if (sampleManager.classList.contains('hidden') || fxChain.classList.contains('hidden')) {
        setTimelineBevel(1);
      } else {
        setTimelineBevel(0);
      }
    }
    sampleTab.addEventListener('click', toggleSample);
    fxTab.addEventListener('click', toggleFX);
    updateTimelineBevel(timelineBevelProgress);

    // 4) Infinite grid dragging on timeline
    let isTimelineDragging = false;
    let dragStart = { x: 0, y: 0 };
    let gridOffset = { x: 0, y: 0 };
    timeline.addEventListener('mousedown', (e) => {
      // If we clicked inside the transport node or one of its children, do NOT drag the grid
      const transportNode = document.getElementById('transportNode');
      if (transportNode.contains(e.target)) return;
      if (e.button !== 0) return;
      isTimelineDragging = true;
      dragStart = { x: e.clientX, y: e.clientY };
      timeline.style.cursor = 'grabbing';
    });
    document.addEventListener('mousemove', (e) => {
      if (!isTimelineDragging) return;
      const dx = e.clientX - dragStart.x;
      const dy = e.clientY - dragStart.y;
      gridOffset.x += dx;
      gridOffset.y += dy;
      timeline.style.backgroundPosition = `${gridOffset.x}px ${gridOffset.y}px`;
      dragStart = { x: e.clientX, y: e.clientY };
    });
    document.addEventListener('mouseup', () => {
      if (isTimelineDragging) {
        isTimelineDragging = false;
        timeline.style.cursor = 'grab';
      }
    });

    // 5) Zoom functionality
    let zoom = 1;
    function updateZoom() {
      const outerSize = 100 * zoom;
      const innerSize = 10 * zoom;
      timeline.style.backgroundSize =
        `${outerSize}px ${outerSize}px, ${outerSize}px ${outerSize}px, ` +
        `${innerSize}px ${innerSize}px, ${innerSize}px ${innerSize}px`;
    }
    updateZoom();
    timeline.addEventListener('wheel', (e) => {
      const transportNode = document.getElementById('transportNode');
      if (transportNode.contains(e.target)) return;
      e.preventDefault();
      zoom *= (e.deltaY < 0) ? 1.1 : 0.9;
      zoom = Math.max(0.1, Math.min(zoom, 10));
      updateZoom();
    });

    /* ================= TRANSPORT NODE LOGIC ================= */
    const transportNode = document.getElementById('transportNode');
    const transportHandle = document.getElementById('transportHandle');
    let isNodeDragging = false;
    let nodeOffsetX = 0;
    let nodeOffsetY = 0;
    transportHandle.addEventListener('mousedown', (e) => {
      if (e.button !== 0) return;
      isNodeDragging = true;
      const rect = transportNode.getBoundingClientRect();
      nodeOffsetX = e.clientX - rect.left;
      nodeOffsetY = e.clientY - rect.top;
      transportHandle.style.cursor = 'grabbing';
    });
    document.addEventListener('mousemove', (e) => {
      if (!isNodeDragging) return;
      const timelineRect = timeline.getBoundingClientRect();
      const newLeft = e.clientX - nodeOffsetX - timelineRect.left;
      const newTop = e.clientY - nodeOffsetY - timelineRect.top;
      transportNode.style.left = newLeft + 'px';
      transportNode.style.top = newTop + 'px';
    });
    document.addEventListener('mouseup', () => {
      if (isNodeDragging) {
        isNodeDragging = false;
        transportHandle.style.cursor = 'grab';
      }
    });

    // Queue button & dropdown
    const queueButton = document.getElementById('queueButton');
    const queueCaret = document.getElementById('queueCaret');
    const queueDropdown = document.getElementById('queueDropdown');
    const queueIcon = document.getElementById('queueIcon');
    const queueLabel = document.getElementById('queueLabel');
    queueCaret.addEventListener('click', (e) => {
      e.stopPropagation();
      queueDropdown.style.display = (queueDropdown.style.display === 'block') ? 'none' : 'block';
    });
    document.addEventListener('click', () => {
      queueDropdown.style.display = 'none';
    });
    queueDropdown.addEventListener('click', (e) => {
      if (e.target.tagName.toLowerCase() === 'li') {
        const newIcon = e.target.getAttribute('data-icon');
        const newLabel = e.target.getAttribute('data-label');
        queueIcon.textContent = newIcon;
        queueLabel.textContent = newLabel;
        queueDropdown.style.display = 'none';
      }
    });

    // Stop & Stop All
    const stopBtn = document.getElementById('stopBtn');
    const stopAllBtn = document.getElementById('stopAllBtn');
    stopBtn.addEventListener('click', () => {
      console.log('Stop clicked!');
    });
    stopAllBtn.addEventListener('click', () => {
      console.log('Stop All clicked!');
    });

    // Batch size
    const batchInput = document.getElementById('batchInput');
    batchInput.addEventListener('change', () => {
      console.log('Batch size changed to:', batchInput.value);
    });


    /* =============== TIMELINE CONTEXT MENU =============== */
    const timelineMenu = document.getElementById('timelineMenu');

    timeline.addEventListener('contextmenu', (e) => {
      // If right-clicking on the transport node, skip
      if (transportNode.contains(e.target)) return;
      e.preventDefault();
      timelineMenu.style.display = 'block';
      timelineMenu.style.left = e.clientX + 'px';
      timelineMenu.style.top = e.clientY + 'px';
    });

    document.addEventListener('click', () => {
      timelineMenu.style.display = 'none';
    });
    document.addEventListener('keydown', (e) => {
      if (e.key === 'Escape') {
        timelineMenu.style.display = 'none';
      }
    });

    // Example handlers for context menu items
    const menuAddNode = document.getElementById('menuAddNode');
    menuAddNode.addEventListener('click', (e) => {
      console.log('Add Node clicked');
      timelineMenu.style.display = 'none';
      openAddNodePanel(e.clientX, e.clientY);
    });
    document.getElementById('menuAddGroup').addEventListener('click', () => {
      console.log('Add Group clicked');
      timelineMenu.style.display = 'none';
    });
    // ... etc.

    /* =============== ADD NODE WINDOW =============== */
    const addNodePanel = document.getElementById('addNodePanel');
    const addNodeHeader = document.getElementById('addNodeHeader');
    const addNodeContent = document.getElementById('addNodeContent');
    const addNodeToggle = document.getElementById('addNodeToggle');
    const addNodeClose = document.getElementById('addNodeClose');

    let isAddNodeDragging = false;
    let addNodeOffsetX = 0;
    let addNodeOffsetY = 0;
    let isAddNodeExpanded = true; // tracks expand/collapse

    function openAddNodePanel(x, y) {
      addNodePanel.style.display = 'block';
      addNodePanel.style.left = x + 'px';
      addNodePanel.style.top = y + 'px';
    }

    // Drag the panel by its header
    addNodeHeader.addEventListener('mousedown', (e) => {
      if (e.button !== 0) return;
      isAddNodeDragging = true;
      const rect = addNodePanel.getBoundingClientRect();
      addNodeOffsetX = e.clientX - rect.left;
      addNodeOffsetY = e.clientY - rect.top;
      addNodeHeader.style.cursor = 'grabbing';
    });
    document.addEventListener('mousemove', (e) => {
      if (!isAddNodeDragging) return;
      addNodePanel.style.left = (e.clientX - addNodeOffsetX) + 'px';
      addNodePanel.style.top  = (e.clientY - addNodeOffsetY) + 'px';
    });
    document.addEventListener('mouseup', () => {
      if (isAddNodeDragging) {
        isAddNodeDragging = false;
        addNodeHeader.style.cursor = 'grab';
      }
    });

    // Expand/Collapse
    addNodeToggle.addEventListener('click', () => {
      isAddNodeExpanded = !isAddNodeExpanded;
      addNodeContent.style.display = isAddNodeExpanded ? 'block' : 'none';
      addNodeToggle.textContent = isAddNodeExpanded ? '▼' : '►';
    });

    // Close
    addNodeClose.addEventListener('click', () => {
      addNodePanel.style.display = 'none';
    });
  </script>
</body>
</html>
