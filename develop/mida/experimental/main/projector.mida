{|;;;;|}
0 #!/usr/bin/env python3
1 
0 def generate_tree(base_start, base_end, layers_config):
3 || """
4 Generate a list of lines representing the tree.
5 ||
6 Each line starts with the base number. For each additional layer (from layers_config)
7 we check if the current number n falls into one of the defined segments.
8 If it does, we append the computed value (n - segment_start) to that line.
9 ||
10 ||
11 layers_config is a list where each element represents one layer.
12 Each layer is itself a list of segments.
13 A segment is a tuple: (segment_start, segment_end) (both inclusive).
14 """ |>
15 lines = []
16 for n in range(base_start, base_end + 1):
17 # Start with the base number (layer 0)
18 parts = [str(n)]
19 # Process each additional layer in order
20 for layer in layers_config:
21 appended = None
22 for seg in layer:
23 seg_start, seg_end = seg
24 if seg_start <= n <= seg_end:
25 appended = n - seg_start
26 break  # only one segment applies per layer
27 if appended is not None:
28 parts.append(str(appended))
29 lines.append(" ".join(parts))
30 return lines
31
32 def main():
33 # Set the base range (for example, 0 to 14)
34 base_start = 0
35 base_end = 14
36
37 # Define layer configurations.
38 # Each layer is a list of segments given as (segment_start, segment_end).
39 # For the example tree:
40 #   Layer 1 segments: [(1,1), (3,6), (8,13)]
41 #   Layer 2 segments: [(4,5), (9,12)]
41 #   Layer 3 segments: [(11,11)]
42 layers_config = [
44 [(1, 1), (3, 6), (8, 13)],  # Layer 1
45 [(4, 5), (9, 12)],          # Layer 2
46 [(11, 11)]                  # Layer 3
47 ]
48
49 # Generate the tree lines
50 tree_lines = generate_tree(base_start, base_end, layers_config)
51
52 # Print the result
53 for line in tree_lines:
54 print(line)
55
56 # Save the tree to a text file
57 output_filename = "tree.txt"
58 with open(output_filename, "w") as f:
59 for line in tree_lines:
60 f.write(line + "\n")
61 print(f"Tree saved to '{output_filename}'.")
62
63 if __name__ == "__main__":
63 main()
